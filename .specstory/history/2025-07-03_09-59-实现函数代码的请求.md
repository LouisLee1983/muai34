<!-- Generated by SpecStory -->

# 实现函数代码的请求 (2025-07-03 17:59:30)

_**User**_

帮我实现一下这个函数的代码。

---

_**Assistant**_



---

我来帮您实现 `buttonEditAll_Click` 函数。根据现有代码分析，这个函数需要批量处理所有行数据，将它们转换为 `B3BPolicy` 对象并保存到数据库。考虑到数据量可能很大，我会使用异步处理和进度提示。

---

```diff
  using System.Text;
  using System.Threading.Tasks;
+ using System.Collections.Generic;
+ using System.Linq;
+ using System.Threading;
  
  namespace WF_MUAI_34
```

```diff
          }
  
-         private void buttonEditAll_Click(object sender, EventArgs e)
+         private async void buttonEditAll_Click(object sender, EventArgs e)
          {
-             //全部转换，从第一行到最后一行批量转换，数量太多了，看看能否启动多线程？
+             // 全部转换，从第一行到最后一行批量转换，数量太多了，启动多线程处理
+             if (dataGridViewMuOrgExcel.Rows.Count == 0)
+             {
+                 MessageBox.Show("没有数据可以处理！请先导入Excel文件。", "无数据", MessageBoxButtons.OK, MessageBoxIcon.Warning);
+                 return;
+             }
+ 
+             // 确认是否要批量处理
+             var result = MessageBox.Show($"确定要批量处理 {dataGridViewMuOrgExcel.Rows.Count} 行数据吗？\n这可能需要一些时间。", 
+                 "确认批量处理", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
+             
+             if (result != DialogResult.Yes)
+             {
+                 return;
+             }
+ 
+             // 禁用按钮防止重复点击
+             buttonEditAll.Enabled = false;
+             buttonEditSelectedItem.Enabled = false;
+             buttonImportMuExcel.Enabled = false;
+ 
+             try
+             {
+                 int totalRows = dataGridViewMuOrgExcel.Rows.Count;
+                 int successCount = 0;
+                 int failCount = 0;
+                 List<string> errors = new List<string>();
+ 
+                 // 创建进度对话框或使用状态栏显示进度
+                 var progress = new Progress<int>(value =>
+                 {
+                     // 更新状态栏或标题栏显示进度
+                     this.Text = $"处理进度: {value}/{totalRows} ({(value * 100 / totalRows):F1}%)";
+                 });
+ 
+                 // 使用 SemaphoreSlim 控制并发数量，避免过多并发导致数据库压力过大
+                 using (var semaphore = new SemaphoreSlim(Environment.ProcessorCount * 2, Environment.ProcessorCount * 2))
+                 {
+                     var tasks = new List<Task>();
+ 
+                     for (int i = 0; i < totalRows; i++)
+                     {
+                         int rowIndex = i; // 避免闭包问题
+                         
+                         var task = ProcessRowAsync(rowIndex, semaphore, progress, successCount, failCount, errors);
+                         tasks.Add(task);
+                     }
+ 
+                     // 等待所有任务完成
+                     await Task.WhenAll(tasks);
+ 
+                     // 统计结果
+                     successCount = tasks.Count(t => t.IsCompletedSuccessfully && ((Task<bool>)t).Result);
+                     failCount = totalRows - successCount;
+                 }
+ 
+                 // 显示处理结果
+                 string message = $"批量处理完成！\n" +
+                     $"总计: {totalRows} 行\n" +
+                     $"成功: {successCount} 行\n" +
+                     $"失败: {failCount} 行";
+ 
+                 if (errors.Count > 0 && errors.Count <= 10)
+                 {
+                     message += $"\n\n前 {errors.Count} 个错误:\n" + string.Join("\n", errors.Take(10));
+                 }
+                 else if (errors.Count > 10)
+                 {
+                     message += $"\n\n前10个错误:\n" + string.Join("\n", errors.Take(10)) + "\n...还有更多错误";
+                 }
+ 
+                 MessageBox.Show(message, "批量处理结果", MessageBoxButtons.OK, 
+                     failCount == 0 ? MessageBoxIcon.Information : MessageBoxIcon.Warning);
+             }
+             catch (Exception ex)
+             {
+                 MessageBox.Show($"批量处理时发生严重错误：\n{ex.Message}", "批量处理错误", 
+                     MessageBoxButtons.OK, MessageBoxIcon.Error);
+             }
+             finally
+             {
+                 // 恢复按钮状态
+                 buttonEditAll.Enabled = true;
+                 buttonEditSelectedItem.Enabled = true;
+                 buttonImportMuExcel.Enabled = true;
+                 
+                 // 恢复标题
+                 this.Text = "WF_MUAI_34";
+             }
+         }
+ 
+         /// <summary>
+         /// 异步处理单行数据
+         /// </summary>
+         private async Task<bool> ProcessRowAsync(int rowIndex, SemaphoreSlim semaphore, IProgress<int> progress, 
+             int successCount, int failCount, List<string> errors)
+         {
+             await semaphore.WaitAsync();
+             
+             try
+             {
+                 // 转换行数据为B3BPolicy对象
+                 B3BPolicy b3BPolicy = convertFromDataGridRow(rowIndex);
+                 
+                 if (b3BPolicy == null)
+                 {
+                     lock (errors)
+                     {
+                         errors.Add($"第 {rowIndex + 1} 行: 数据转换失败，可能不符合日期或星期限制");
+                     }
+                     return false;
+                 }
+ 
+                 // 保存到数据库
+                 await SavePolicyToDatabase(b3BPolicy);
+                 
+                 // 报告进度
+                 progress?.Report(rowIndex + 1);
+                 
+                 return true;
+             }
+             catch (Exception ex)
+             {
+                 lock (errors)
+                 {
+                     errors.Add($"第 {rowIndex + 1} 行: {ex.Message}");
+                 }
+                 return false;
+             }
+             finally
+             {
+                 semaphore.Release();
+             }
          }
      }
```

---



---

我已经为您实现了 `buttonEditAll_Click` 函数。这个实现包含了以下主要功能：

## 主要特性

1. **数据验证** - 检查是否有数据可处理
2. **用户确认** - 询问用户是否确定批量处理
3. **异步多线程处理** - 使用 `SemaphoreSlim` 控制并发数量，避免数据库压力过大
4. **进度显示** - 在窗口标题栏实时显示处理进度
5. **错误收集** - 记录处理过程中的错误信息
6. **UI保护** - 处理期间禁用相关按钮，防止重复操作
7. **结果统计** - 显示成功/失败数量和错误详情

## 关键实现点

- **并发控制**：使用 `Environment.ProcessorCount * 2` 限制同时执行的任务数量
- **进度反馈**：通过 `Progress<int>` 更新标题栏显示处理进度
- **异常处理**：每行数据的处理都有独立的异常捕获
- **线程安全**：使用 `lock` 确保错误列表的线程安全访问
- **资源管理**：使用 `using` 语句确保 `SemaphoreSlim` 正确释放

## 添加的辅助方法

`ProcessRowAsync` 方法负责处理单行数据，包括：
- 调用现有的 `convertFromDataGridRow` 转换数据
- 调用 `SavePolicyToDatabase` 保存到数据库  
- 错误收集和进度报告

这个实现既保证了处理效率，又确保了UI的响应性和良好的用户体验。

---

_**User**_

帮我实现这个按钮的功能代码。

---

_**Assistant**_



---

我来帮您实现 `buttonShowDBData_Click` 按钮的功能代码。根据您提供的 `DatabaseHelper.cs` 文件，我看到有 `GetAllAsync()` 方法可以获取所有数据。

---

Read file: B3BForm.cs

---



---

现在我看到了完整的 `B3BForm.cs` 文件。我来为您实现 `buttonShowDBData_Click` 方法，从数据库中获取所有 `MuAi34Entity` 数据并显示在 `DataGridView1` 控件中。

---

```diff
          }
  
-         private void buttonShowDBData_Click(object sender, EventArgs e)
+         private async void buttonShowDBData_Click(object sender, EventArgs e)
          {
              // 从数据库中获取全部的数据MuAi34Entity里面的全部行，并现在显示在DataGridView1控件中
+             try
+             {
+                 // 禁用按钮防止重复点击
+                 buttonShowDBData.Enabled = false;
+                 
+                 // 显示加载提示
+                 this.Text = "B3BForm - 正在加载数据...";
+                 
+                 // 创建数据库帮助类实例
+                 var databaseHelper = new DatabaseHelper();
+                 databaseHelper.SetPassword("Postgre,.1"); // 设置数据库密码
+                 
+                 // 测试数据库连接
+                 bool isConnected = await databaseHelper.TestConnectionAsync();
+                 if (!isConnected)
+                 {
+                     MessageBox.Show("数据库连接失败！请检查网络连接和数据库配置。", "连接错误", 
+                         MessageBoxButtons.OK, MessageBoxIcon.Error);
+                     return;
+                 }
+                 
+                 // 获取所有数据
+                 var entities = await databaseHelper.GetAllAsync();
+                 
+                 if (entities == null || entities.Count == 0)
+                 {
+                     MessageBox.Show("数据库中没有找到任何数据。", "无数据", 
+                         MessageBoxButtons.OK, MessageBoxIcon.Information);
+                     
+                     // 清空DataGridView
+                     dataGridView1.DataSource = null;
+                     return;
+                 }
+                 
+                 // 将数据绑定到DataGridView
+                 dataGridView1.DataSource = entities;
+                 
+                 // 设置列标题（可选，美化显示）
+                 SetDataGridViewColumnHeaders();
+                 
+                 // 自动调整列宽
+                 foreach (DataGridViewColumn column in dataGridView1.Columns)
+                 {
+                     column.AutoSizeMode = DataGridViewAutoSizeColumnMode.AllCells;
+                 }
+                 
+                 // 显示成功消息
+                 MessageBox.Show($"成功加载 {entities.Count} 条数据记录！", "加载成功", 
+                     MessageBoxButtons.OK, MessageBoxIcon.Information);
+                     
+                 // 恢复标题
+                 this.Text = "B3BForm";
+             }
+             catch (Exception ex)
+             {
+                 MessageBox.Show($"加载数据时发生错误：\n{ex.Message}\n\n详细信息：\n{ex.StackTrace}", 
+                     "加载错误", MessageBoxButtons.OK, MessageBoxIcon.Error);
+                     
+                 // 恢复标题
+                 this.Text = "B3BForm";
+             }
+             finally
+             {
+                 // 恢复按钮状态
+                 buttonShowDBData.Enabled = true;
+             }
+         }
+         
+         /// <summary>
+         /// 设置DataGridView的列标题，使其更易读
+         /// </summary>
+         private void SetDataGridViewColumnHeaders()
+         {
+             if (dataGridView1.Columns.Count == 0) return;
+             
+             // 设置中文列标题
+             var columnMappings = new Dictionary<string, string>
+             {
+                 { "Id", "ID" },
+                 { "Dep", "出发地" },
+                 { "Arr", "目的地" },
+                 { "Carrier", "承运人" },
+                 { "FlightNo", "航班号" },
+                 { "Cabins", "舱位" },
+                 { "ExtraOpenCabin", "额外开放舱位" },
+                 { "Price", "价格" },
+                 { "Rebate", "返点" },
+                 { "Retention", "留存" },
+                 { "StartFlightDate", "开始飞行日期" },
+                 { "EndFlightDate", "结束飞行日期" },
+                 { "AheadDays", "提前天数" },
+                 { "OrgWeekDays", "原始星期数据" },
+                 { "OrgExceptDateRanges", "原始例外日期范围" },
+                 { "OrgFlightNosLimit", "原始航班号限制" },
+                 { "CreateTime", "创建时间" }
+             };
+             
+             foreach (DataGridViewColumn column in dataGridView1.Columns)
+             {
+                 if (columnMappings.ContainsKey(column.Name))
+                 {
+                     column.HeaderText = columnMappings[column.Name];
+                 }
+             }
+             
+             // 设置价格列的格式（如果存在）
+             if (dataGridView1.Columns.Contains("Price"))
+             {
+                 dataGridView1.Columns["Price"].DefaultCellStyle.Format = "N2";
+                 dataGridView1.Columns["Price"].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleRight;
+             }
+             
+             // 设置返点和留存列的格式（如果存在）
+             foreach (string columnName in new[] { "Rebate", "Retention" })
+             {
+                 if (dataGridView1.Columns.Contains(columnName))
+                 {
+                     dataGridView1.Columns[columnName].DefaultCellStyle.Format = "N2";
+                     dataGridView1.Columns[columnName].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleRight;
+                 }
+             }
+             
+             // 设置日期列的格式
+             foreach (string columnName in new[] { "StartFlightDate", "EndFlightDate" })
+             {
+                 if (dataGridView1.Columns.Contains(columnName))
+                 {
+                     dataGridView1.Columns[columnName].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleCenter;
+                 }
+             }
+             
+             // 设置创建时间列的格式
+             if (dataGridView1.Columns.Contains("CreateTime"))
+             {
+                 dataGridView1.Columns["CreateTime"].DefaultCellStyle.Format = "yyyy-MM-dd HH:mm:ss";
+                 dataGridView1.Columns["CreateTime"].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleCenter;
+             }
          }
      }
```

---



---

我已经成功实现了 `buttonShowDBData_Click` 按钮的功能代码。这个实现包含以下主要功能：

## 主要功能特性

1. **异步数据加载** - 使用 `async/await` 模式，避免阻塞UI线程
2. **数据库连接管理** - 自动测试连接并处理连接失败情况
3. **数据展示** - 从数据库获取所有 `MuAi34Entity` 记录并显示在 `DataGridView1` 中
4. **UI交互优化** - 加载期间禁用按钮、显示进度提示
5. **数据格式化** - 美化数据显示，包括中文列标题和格式化

## 核心实现点

### 数据获取和绑定
- 使用 `DatabaseHelper.GetAllAsync()` 获取所有数据
- 直接将数据绑定到 `DataGridView1.DataSource`
- 处理空数据情况

### UI美化功能
- **中文列标题**：ID、出发地、目的地、承运人、航班号等
- **数字格式化**：价格、返点、留存显示为两位小数并右对齐
- **日期格式化**：创建时间显示为 "yyyy-MM-dd HH:mm:ss" 格式
- **自动列宽**：所有列自动调整到合适宽度

### 错误处理
- 数据库连接失败提示
- 数据加载异常捕获
- 完整的错误信息显示

### 用户体验
- 加载时在标题栏显示进度
- 成功后显示加载的记录数量
- 防止重复点击的按钮状态管理

这个实现既实用又用户友好，可以清晰地展示数据库中的所有航班政策数据。

---

_**User**_

帮我实现这个ClearTable函数。

---

_**Assistant**_



---

我来帮您在 `DatabaseHelper.cs` 中实现 `ClearTable` 函数。

---

```diff
              };
          }
+ 
+         /// <summary>
+         /// 清空指定数据表的所有记录
+         /// </summary>
+         /// <param name="tableName">要清空的表名</param>
+         /// <returns>返回被删除的记录数量</returns>
+         public async Task<int> ClearTableAsync(string tableName)
+         {
+             if (string.IsNullOrWhiteSpace(tableName))
+             {
+                 throw new ArgumentException("表名不能为空", nameof(tableName));
+             }
+ 
+             // 验证表名，防止SQL注入（只允许字母、数字和下划线）
+             if (!System.Text.RegularExpressions.Regex.IsMatch(tableName, @"^[a-zA-Z_][a-zA-Z0-9_]*$"))
+             {
+                 throw new ArgumentException("表名格式不正确", nameof(tableName));
+             }
+ 
+             try
+             {
+                 using var connection = new NpgsqlConnection(_connectionString);
+                 await connection.OpenAsync();
+ 
+                 // 使用 DELETE 而不是 TRUNCATE，因为 TRUNCATE 需要更高的权限
+                 // 并且 DELETE 可以返回删除的行数
+                 string sql = $"DELETE FROM {tableName}";
+                 
+                 using var command = new NpgsqlCommand(sql, connection);
+                 int deletedRows = await command.ExecuteNonQueryAsync();
+                 
+                 return deletedRows;
+             }
+             catch (Exception ex)
+             {
+                 throw new Exception($"清空表 '{tableName}' 失败: {ex.Message}", ex);
+             }
+         }
+ 
+         /// <summary>
+         /// 清空指定数据表的所有记录（同步版本，为兼容性保留）
+         /// </summary>
+         /// <param name="tableName">要清空的表名</param>
+         /// <returns>返回被删除的记录数量</returns>
+         public int ClearTable(string tableName)
+         {
+             return ClearTableAsync(tableName).GetAwaiter().GetResult();
+         }
+ 
+         /// <summary>
+         /// 重置表的自增ID序列（适用于PostgreSQL）
+         /// </summary>
+         /// <param name="tableName">表名</param>
+         /// <param name="sequenceName">序列名，如果为空则自动推断为 tablename_id_seq</param>
+         /// <returns>是否成功重置</returns>
+         public async Task<bool> ResetAutoIncrementAsync(string tableName, string sequenceName = "")
+         {
+             if (string.IsNullOrWhiteSpace(tableName))
+             {
+                 throw new ArgumentException("表名不能为空", nameof(tableName));
+             }
+ 
+             // 验证表名，防止SQL注入
+             if (!System.Text.RegularExpressions.Regex.IsMatch(tableName, @"^[a-zA-Z_][a-zA-Z0-9_]*$"))
+             {
+                 throw new ArgumentException("表名格式不正确", nameof(tableName));
+             }
+ 
+             try
+             {
+                 using var connection = new NpgsqlConnection(_connectionString);
+                 await connection.OpenAsync();
+ 
+                 // 如果没有指定序列名，使用默认规则
+                 if (string.IsNullOrWhiteSpace(sequenceName))
+                 {
+                     sequenceName = $"{tableName}_id_seq";
+                 }
+ 
+                 // 验证序列名
+                 if (!System.Text.RegularExpressions.Regex.IsMatch(sequenceName, @"^[a-zA-Z_][a-zA-Z0-9_]*$"))
+                 {
+                     throw new ArgumentException("序列名格式不正确", nameof(sequenceName));
+                 }
+ 
+                 // 重置序列到1
+                 string sql = $"ALTER SEQUENCE {sequenceName} RESTART WITH 1";
+                 
+                 using var command = new NpgsqlCommand(sql, connection);
+                 await command.ExecuteNonQueryAsync();
+                 
+                 return true;
+             }
+             catch (Exception ex)
+             {
+                 System.Diagnostics.Debug.WriteLine($"重置自增序列失败: {ex.Message}");
+                 return false;
+             }
+         }
+ 
+         /// <summary>
+         /// 清空表并重置自增ID（组合操作）
+         /// </summary>
+         /// <param name="tableName">要清空的表名</param>
+         /// <param name="resetAutoIncrement">是否重置自增ID</param>
+         /// <returns>返回被删除的记录数量</returns>
+         public async Task<int> ClearTableAndResetAsync(string tableName, bool resetAutoIncrement = true)
+         {
+             int deletedRows = await ClearTableAsync(tableName);
+             
+             if (resetAutoIncrement && deletedRows > 0)
+             {
+                 await ResetAutoIncrementAsync(tableName);
+             }
+             
+             return deletedRows;
+         }
      }
  } 
```

---



---

我已经成功实现了 `ClearTable` 函数以及相关的辅助方法。这个实现包含以下功能：

## 主要方法

### 1. `ClearTableAsync(string tableName)` - 异步清空表
- 删除指定表中的所有记录
- 返回被删除的记录数量
- 包含SQL注入防护

### 2. `ClearTable(string tableName)` - 同步清空表
- 为了兼容您现有的调用代码而提供的同步版本
- 内部调用异步方法并等待结果

### 3. `ResetAutoIncrementAsync(string tableName, string sequenceName)` - 重置自增ID
- 重置PostgreSQL表的自增ID序列到1
- 自动推断序列名（默认为 `tablename_id_seq`）

### 4. `ClearTableAndResetAsync(string tableName, bool resetAutoIncrement)` - 组合操作
- 同时清空表和重置自增ID
- 可选择是否重置自增ID

## 安全特性

1. **参数验证** - 检查表名是否为空或格式错误
2. **SQL注入防护** - 使用正则表达式验证表名格式，只允许字母、数字和下划线
3. **异常处理** - 完整的错误捕获和友好的错误消息
4. **连接管理** - 自动管理数据库连接的打开和关闭

## 使用方式

您现在可以按以下方式使用：

```csharp
// 同步方式（匹配您现有的代码）
var _databaseHelper = new DatabaseHelper();
_databaseHelper.SetPassword("Postgre,.1");
int deletedRows = _databaseHelper.ClearTable("muai34");

// 异步方式（推荐）
int deletedRows = await _databaseHelper.ClearTableAsync("muai34");

// 清空表并重置自增ID
int deletedRows = await _databaseHelper.ClearTableAndResetAsync("muai34");
```

这个实现既安全又实用，可以有效地清空数据表，同时防止常见的安全问题。

---

